## Tugas 7
**Jelaskan apa itu widget tree pada Flutter dan bagaimana hubungan parent-child (induk-anak) bekerja antar widget.** 

Pada Flutter, semua hal atau elemen merupakan widget. Mulai dari tombol (button), teks (text), tata letak (layout), hingga keseluruhan aplikasi yang dibuat, semuanya adalah widget. Untuk dapat membuat suatu antarmuka aplikasi di Flutter, digunakan susunan widget yang disebut widget tree. Sesuai dengan namanya, widget tree adalah susunan atau struktur yang berbentuk pohon dimana setiap nodenya merupakan sebuah widget. Konsep ini digunakan Flutter untuk membangun antarmuka berdasarkan struktur hierarkis yang menggambarkan hubungan antar-widget, yaitu hubungan induk–anak (parent–child relationship). Konsep widget tree sangat membantu dalam pengelolaan tampilan aplikasi. Ketika terjadi perubahan (misalnya data diperbarui atau tombol ditekan), Flutter dapat mengetahui bagian mana dari tampilan yang perlu diperbarui berdasarkan struktur widget tree tersebut. Hanya widget yang mengalami perubahan yang akan dibuat ulang (rebuilt), sehingga proses pembaruan menjadi lebih efisien. Dalam struktur flutter, hubungan antar widget dapat dikatakan sebagai parent-child relationship, dimana satu widget berperan sebagai parent dan satu atau lebih widget dapat berperan sebagai child. Parent widget adalah widget yang membungkus child widget atau widget lain. Parent widget dapat mengatur posisi, ukuran, ataupun aktivitas yang akan dilakukan oleh child widget. Sedangkan child widget adalah widget yang berada di dalam widget parent. Contohnya adalah ```Center(child: Text("hi"))```. Pada contoh tersebut, Text merupakan child dari Center. Parent widget Center menentukan posisi child-nya (Text) agar tulisan "hi" dapat terlihat di tengah layar. Beberapa widget hanya dapat memiliki satu child, seperti Center, Container, dan Padding. Namun, ada juga widget yang dapat memiliki banyak child, yang umumnya menggunakan properti children, seperti Column, Row, ListView, dan GridView. Suatu widget dapat berperan menjadi parent dan juga child di suatu waktu yang bersamaan. Berdasarkan hubungan parent-child yang dimiliki oleh widget pada Flutter, akan tercipta suatu hubungan seperti pohon dimana root nya merupakan parent utama yang membungkus keseluruhan anak atau widget lainnya dan widget-widget lainnya yang merupakan anak dari root juga dapat berperan sebagai parent yang membungkus widget child lain. 

**Sebutkan semua widget yang kamu gunakan dalam proyek ini dan jelaskan fungsinya.** 

Widget pada *menu.dart*
* Scaffold : Scaffold merupakan widget utama yang menjadi struktur dasar dari suatu tampilan halaman atau antarmuka Flutter. Widget ini berfungsi sebagai penyedia layout dasar seperti AppBar dan Body yang berisi keseluruhan isi halaman Turboa Shop.
* AppBar : Appbar merupakan widget yang bertanggung jawab untuk bagian atas halaman atau header yang berisi judul aplikasi. Pada proyek ini, Appbar digunakan untuk menampilkan teks toko atau "Turboa Shop" dengan warna background yang sesuai dengan warna primer aplikasi
* Text : Text merupakan widget yang digunakan untuk menampilkan tulisan atau teks pada layar. Pada widget ini, dapat diatur style, font, warna ataupun pengaturan tulisan yang akan ditampilkan pada layar.
* Padding : Padding merupakan widget yang digunakan untuk memberikan jarak di sekitar widget lain yang dibungkus olehnya. Salah satu contoh penggunaan pada proyek ini adalah ```Padding( padding: const EdgeInsets.all(16))``` yang berarti bahwa diberikan jarak sekitar 16 pixel agar isi halaman atau body tidak menempel langsung ke ujung layar. Walaupun padding berperan sebagai widget child dari body, namun Padding juga berperan sebagai parent dari childnya (widget yang dibungkus di dalamnya).
* Column : Column adalah widget yang digunakan untuk menata elemen atau child di dalamnya secara vertikal (atas ke bawah). Pada proyek ini, widget Column digunakan untuk menyusun berbagai macam elemen di halaman utama, seperti Text, informasi, dan GridView. 
* Sizedbox : Sizedbox adalah widget yang digunakan untuk memberikan jarak (kosong atau tidak berisi apa-apa) antar widget dengan suatu tinggi atau lebar tertentu yang dapat disesuaikan dengan kebutuhan aplikasi.
* Card : Card adalah suatu widget yang dapat menampilkan konten atau isi dalam bentuk kartu dengan menambahkan efek shadow. Pada proyek ini, widget Card digunakan untuk menampilkan informasi berupa data diri dengan shadow yang membuat kartu atau elemen menjadi lebih menonjol
* Row : Row adalah suatu widget yang digunakan untuk menata elemen secara horizontal (kiri ke kanan). Pada proyek ini, Row digunakan di bagian Informasi untuk menampilkan dua bagian, yaitu icon profil yang berada di sebelah kiri dan teks yang berisi data diri di sebelah kanan
* Icon : Icon adalah suatu widget yang digunakan untuk menampilkan ikon atau gambar dari Icons. Icons telah memiliki sejumlah ikon atau gambar lengkap yang dapat digunakan secara langsung. Pada bagian informasi, widget ini digunakan untuk menampilkan icon profil, sedangkan pada ItemCard, icon digunakan untuk menampilkan icon tiap button.
* RichText dan TextSpan : RichText dan TextSpan adalah widget yang digunakan untuk menampilkan teks dengan dua atau lebih gaya yang berbeda dalam suatu baris. Widget ini digunakan pada bagian informasi, dimana nama ingin ditampilkan dengan bold sedangkan nama asli tidak.
* GridView.count : GridView.count adalah widget yang digunakan untuk menampilkan elemen-elemen dalam bentuk grid atau tabel kotak-kotak. Widget ini digunakan untuk menampilkan tiga menu utama aplikasi, yaitu All Products, My Products, dan Create Products dalam tiga kolom agar terlihat rapi.
* Material : Material adalah widget yang digunakan untuk memberikan efek dan gaya khas Material Design, seperti warna latar, bayangan, dan interaksi sentuhan. Widget ini digunakan dalam ItemCard untuk memberikan warna latar belakang dan efek klik yang khas sesuai gaya Material Design.
* InkWell : InkWell adalah widget yang digunakan untuk memberikan efek ripple (gelombang air) saat suatu widget disentuh atau diklik. Widget ini digunakan agar setiap button (ItemCard) dapat merespons sentuhan pengguna dan menampilkan SnackBar saat diklik.
* Container : Container adalah widget yang digunakan untuk mengatur padding, ukuran, warna, atau dekorasi dari widget lain. Container berperan sebagai tempat atau wadah untuk isinya (childnya). Widget ini digunakan di dalam ItemCard untuk memberikan padding dan merapikan tata letak isi di setiap kotak button.
* SnackBar dan ScaffoldMessenger : SnackBar dan ScaffoldMessenger adalah widget yang digunakan untuk menampilkan notifikasi sementara (akan hilang setelah beberapa saat) di bagian bawah layar. Widget ini digunakan ketika pengguna menekan salah satu tombol menu, dimana akan ditampilkan pesan sementara seperti "Kamu telah menekan tombol ..." sebagai feedback atau dampak dari aktivitas pengguna.
* Center : Center adalah widget yang digunakan untuk memposisikan widget anaknya di tengah dari ruang yang tersedia. Widget ini digunakan di dalam ItemCard agar ikon dan teks menu tampil tepat di tengah kotak.

Widget pada *main.dart*
* MaterialApp : MaterialApp adalah widget utama yang menjadi root aplikasi Flutter berbasis Material Design. Widget ini digunakan untuk mengatur tema (theme), judul aplikasi (title), serta halaman awal (home).
* MyApp (StatelessWidget) : MyApp adalah widget utama yang membungkus seluruh aplikasi. Widget ini merupakan root widget yang akan memanggil MaterialApp.
* MyHomePage (StatelessWidget) : MyHomePage adalah widget yang digunakan untuk menampilkan halaman utama aplikasi yang berisi struktur tampilan, seperti Scaffold, AppBar, dan Body.

**Apa fungsi dari widget MaterialApp? Jelaskan mengapa widget ini sering digunakan sebagai widget root.**

MaterialApp merupakan widget utama bawaan Flutter yang berfungsi sebagai kerangka dasar aplikasi dan biasanya digunakan sebagai root widget. Widget ini merupakan suatu pembungkus atau parent dari berbagai komponen Material Design (dari Google), sehingga developer dapat menggunakan berbagai widget seperti Text, AppBar, Scaffold, ListView, Padding, ThemeData, dan sebagainya. Dengan widget MaterialApp, developer dapat membangun suatu aplikasi Flutter yang memiliki tampilan yang konsisten, menarik, serta mengikuti standar desain Material Design. Secara umum, MaterialApp berfungsi untuk mengatur struktur dasar, tema, dan navigasi aplikasi agar aplikasi dapat berjalan dan berfungsi dengan baik. Pengaturan atau konfigurasi ini dilakukan melalui penambahan atau penyesuaian properti seperti theme, colorScheme, dan fontFamily. Melalui properti ini, developer dapat menentukan warna utama, warna sekunder, serta gaya teks yang digunakan di seluruh aplikasi. Home juga merupakan salah satu properti yang sering digunakan, yaitu untuk menentukan halaman awal yang akan muncul saat aplikasi dijalankan. Selain itu, MaterialApp juga menyediakan sistem navigasi lengkap untuk jalannya aplikasi menggunakan routes, Navigator, atau onGenerateRoute, sehingga developer dapat lebih mudah mengatur aktivitas perpindahan antar halaman sesuai dengan keinginannya. Selain fungsi-fungsi tersebut, MaterialApp juga mendukung pengaturan judul aplikasi dan bahasa lokal melalui properti title dan localizationsDelegates. Widget ini memberikan adanya keselarasan pada aplikasi dengan komponen Material Design, seperti Scaffold, AppBar, FloatingActionButton, dan SnackBar, yang membuat antarmuka aplikasi tampak profesional dan seragam. MaterialApp hampir selalu dijadikan widget root karena ia menyediakan context Material Design yang dibutuhkan oleh banyak widget di Flutter. Tanpa MaterialApp, beberapa widget seperti ScaffoldMessenger atau Theme.of(context) tidak akan dapat berfungsi dengan baik. Dengan menjadikannya sebagai widget utama, developer dapat mengatur tema global, sistem navigasi, serta struktur aplikasi dalam satu bagian secara efisien dan terorganisir sehingga dapat digunakan di berbagai halaman.

**Jelaskan perbedaan antara StatelessWidget dan StatefulWidget. Kapan kamu memilih salah satunya?** 

StatelessWidget dan StatefulWidget adalah dua jenis widget utama di Flutter yang digunakan untuk membangun suatu tampilan antarmuka, tetapi keduanya memiliki perbedaan mendasar dalam cara menangani perubahan keadaan (state). StatelessWidget adalah widget yang menyediakan tampilan yang memiliki sifat tidak akan berubah setelah dibuat, bahkan ketika terjadi suatu interaksi dari user atau ketika ditemukan adanya perubahan atau perbedaan nilai dari variabel dan nilai yang ditampilkan. Hal ini berarti bahwa semua data atau tampilan yang dimiliki pada StatelessWidget bersifat tetap. Jika terjadi suatu perubahan data, maka widget tersebut harus dibangun ulang dari awal. Pada proyek ini, baru digunakan StatelessWidget yang berarti halaman utama tidak akan menampilkan perubahan meskipun ada aktivitas yang dilakukan oleh user. Salah satu contoh penggunaannya adalah tampilan teks, logo, ikon, ataupun menu button All Products, My Products, dan Create Product yang tidak berubah meskipun diklik. StatelessWidget digunakan ketika diinginkan tampilan yang tidak bergantung pada input atau interaksi pengguna. Dengan kata lain, StatelessWidget cocok digunakan ketika tampilan tidak berubah atau statis. 

Sedangkan, StatefulWidget adalah widget yang mempunyai sifat dinamis atau memiliki state yang bisa senantiasa berubah selama aplikasi berjalan. Widget ini dapat berubah ketika terdapat interaksi dari user maupun ketika terjadi suatu perubahan dari variabel dan nilai yang ditemukan. Widget ini memiliki dua bagian, yaitu StatefulWidget itu sendiri sebagai kerangka dan state class yang menyimpan dan mengelola data yang bisa berubah. Jika terjadi suatu perubahan pada data di dalam state, maka Flutter akan memanggil setState() untuk membangun ulang tampilan aplikasi sesuai data terbaru. Proses pada widget ini berbeda dengan stateless pada bagian setelah proses dari Constructor menuju Build. Constructor adalah tahap awal yang berfungsi untuk membuat setiap state dengan keadaan yang ingin diterapkan, sedangkan Build merupakan tahap dimana semua widget dan state dibangun untuk antarmuka. Pada StatefulWidget, sebelum masuk ke tahapan build, terjadi suatu tahap yaitu Internal State yang merupakan proses penambahan state atau perubahan data sehingga ketika internal state terjadi, sistem akan melakukan re-render tampilan dari widget awal. Salah satu contoh penggunaannya adalah template awal aplikasi ketika Flutter dibuat, yaitu adanya counter yang menampilkan nilai yang senantiasa berubah saat tombol ditekan, form input pengguna, atau tampilan dinamis. StatefulWidget cocok digunakan untuk tampilan yang memiliki interaksi dengan pengguna atau data dinamis yang dapat menyebabkan perubahan pada tampilan.

**Apa itu BuildContext dan mengapa penting di Flutter? Bagaimana penggunaannya di metode build?** 

BuildContext adalah suatu istilah yang seringkali ditemukan di Flutter yang berperan penting dalam widget tree, proses rendering, dan navigasi. BuildContext adalah suatu objek yang digunakan oleh Flutter untuk memberikan informasi mengenai lokasi dari suatu widget di dalam widget tree. BuildContext merepresentasikan build context saat ini atau kondisi widget mana yang sedang dibuat atau diupdate. Secara sederhana, BuildContext dapat dianggap sebagai referensi atau alamat dari sebuah widget di dalam struktur hierarkis widget tree. Setiap widget di dalam aplikasi Flutter memiliki akses untuk BuildContext-nya masing-masing. BuildContext memiliki berbagai macam fungsi penting, yaitu untuk konfigurasi widget dan menentukan properti, melakukan lokalisasi yang sesuai dengan bahasa pengguna, mengakses tema aplikasi yang sedang digunakan agar tampilan aplikasi tetap konsisten, mengatur sistem navigasi aplikasi (misalnya ketika berpindah ke halaman lain), serta mengambil data state atau merubah suatu state. Hal ini dikarenakan BuildContext memberikan akses ke informasi yang berkaitan dengan struktur widget yang membuat developer dapat mengakses dan melakukan semua fungsi tersebut. Ketika Flutter membangun tampilan melalui metode build(), ia selalu memberikan parameter BuildContext context agar widget mengetahui posisinya di dalam widget tree dan sumber daya apa saja yang dapat diakses dari lingkungannya. BuildContext dibuat secara otomatis ketika sebuah widget dimasukkan ke dalam widget tree. Parameter context ini memungkinkan widget untuk mengambil data dari widget parent, mengakses tema global atau lokal, melakukan navigasi, serta menggunakan provider atau manajemen state lainnya. Misalnya, pemanggilan Theme.of(context) menggunakan BuildContext untuk mengambil tema dari MaterialApp sebagai parent-nya. Dengan demikian, dapat disimpulkan bahwa BuildContext sangat penting karena berfungsi sebagai penghubung antar widget di dalam widget tree. BuildContext memungkinkan suatu widget mengambil data dari ancestor tanpa harus meneruskannya secara manual dan menjadi komponen penting bagi berbagai fitur seperti tema, navigasi, media query, dan provider. Selain itu, objek BuildContext juga membentuk hierarki yang mencerminkan struktur widget tree, dengan akar (root) yang biasanya berada pada BuildContext dari widget paling atas, seperti yang ada di dalam runApp(). Semakin dalam posisi widget dalam widget tree, maka semakin spesifik pula konteksnya. Setiap BuildContext bersifat unik dan tidak dapat dipertukarkan karena terikat pada widget dan subtree-nya masing-masing. Oleh karena itu, jika ingin mengakses data dari bagian lain dari widget tree, perlu digunakan BuildContext yang sesuai.

**Jelaskan konsep "hot reload" di Flutter dan bagaimana bedanya dengan "hot restart".**

Meskipun terlihat mirip, hot reload dan hot restart memiliki suatu perbedaan yang mendasar. Hot reload adalah suatu fitur pada Flutter yang memungkinkan developer untuk melihat perubahan pada tampilan aplikasi secara instan tanpa perlu memulai ulang seluruh aplikasi. Saat developer mengubah kode dan menyimpannya, Flutter akan secara otomatis mengompilasi kode yang telah dimodifikasi dan mengirimkannya ke Dart Virtual Machine (VM) yang sedang berjalan. VM kemudian memperbarui struktur widget tree aplikasi agar dapat sesuai dengan perubahan yang dilakukan tersebut. Proses hot reload biasanya berlangsung dengan sangat cepat dan seringkali hanya membutuhkan waktu kurang dari satu detik. Hal ini memungkinkan developer untuk melihat hasil modifikasi kode mereka hampir secara real-time tanpa kehilangan state aplikasi dan tanpa perlu menunggu proses kompilasi dan deployment yang lama. Hot reload sangat berguna dan biasa digunakan untuk mengubah tampilan UI, menambahkan fitur baru, menambahkan widget baru, memperbaiki bug kecil tanpa merubah state aplikasi, melakukan eksperimen cepat, menyesuaikan logika lokal, mengatur animasi atau transisi, dan melakukan penyesuaian pada teks dan warna. Dengan hot reload, developer dapat melakukan eksperimen dengan berbagai desain dan implementasi tanpa kehilangan state aplikasi saat ini. Hot reload hanya memperbarui bagian kode yang berubah, sehingga lebih efisien dalam penggunaan memori. Misalnya, jika hanya dilakukan pengubahan terhadap warna tombol, cukup tekan ikon petir di IDE atau tombol r di terminal, dan hasilnya akan langsung terlihat tanpa menutup aplikasi dengan sangat cepat. Sementara itu, hot restart merupakan suatu proses yang lebih menyeluruh dibandingkan dengan hot reload. Saat melakukan hot restart, Flutter akan memuat ulang seluruh aplikasi dari awal, termasuk menghapus semua state dan menginisialisasi ulang semua variabel. Artinya, aplikasi akan kembali ke kondisi awal seperti baru dijalankan. Meskipun hot restart membutuhkan waktu yang lebih lama dibandingkan dengan hot reload, proses ini masih jauh lebih cepat dibandingkan dengan menjalankan ulang aplikasi secara manual. Hot restart merupakan suatu fitur yang sangat berguna ketika developer melakukan suatu perubahan besar atau ketika hot reload saja tidak cukup untuk menampilkan perubahan yang telah diterapkan. Hot restart bekerja dengan mengompilasi ulang seluruh aplikasi yang membuat proses ini membutuhkan lebih banyak memori dibandingkan dengan hot reload. Hot restart lebih cocok digunakan ketika dilakukan perubahan terhadap state global, melakukan modifikasi besar pada struktur aplikasi, melakukan perubahan pada logika inisialisasi, menambahkan plugin atau dependensi baru, melakukan perubahan logika kompleks, serta melakukan pengujian terhadap state awal.

## Tugas 8

**Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement() pada Flutter. Dalam kasus apa sebaiknya masing-masing digunakan pada aplikasi Football Shop kamu?**

Meskipun terlihat mirip, Navigator.push() dan Navigator.pushReplacement() memiliki perbedaan mendasar dalam cara mengatur perpindahan halaman pada aplikasi Flutter. Keduanya menggunakan widget Navigator, yaitu widget yang berfungsi untuk mengelola serangkaian halaman (child widgets) dengan prinsip stack, di mana halaman yang paling baru atau terakhir diakses akan berada di posisi paling atas (FIFO). Metode Navigator.push() digunakan untuk menambahkan halaman baru ke atas tumpukan halaman yang sedang aktif. Artinya, halaman baru akan terbuka di atas halaman sebelumnya, dan pengguna masih dapat kembali ke halaman sebelumnya dengan menekan tombol back yang merupakan implementasi metode Navigator.pop(). Dalam konteks aplikasi Football Shop, Navigator.push() digunakan ketika pengguna ingin menambah produk baru melalui tombol "Tambah Produk" di menu atau drawer. Dengan menggunakan Navigator.push(), pengguna masih dapat kembali ke halaman utama setelah ia memencet dan melihat tampilan (diarahkan ke) halaman form, sehingga alur navigasi menjadi lebih fleksibel dan natural. Dapat disimpulkan bahwa Navigator.push() cocok digunakan untuk perpindahan tampilan dimana pengguna cenderung ingin kembali ke halaman sebelumnya. Sementara itu, Navigator.pushReplacement() digunakan untuk mengganti halaman yang sedang aktif dengan halaman baru tanpa menumpuknya di atas halaman lama. Halaman sebelumnya akan dihapus dari stack, sehingga pengguna tidak dapat kembali ke halaman tersebut dan akan direplace atau digantikan dengan halaman yang baru. Pada aplikasi Football Shop, metode ini cocok digunakan setelah pengguna selesai menambahkan produk melalui form. Setelah data produk terisi semuanya dan berhasil disimpan (pengguna menekan tombol save), pengguna akan menerima pop up berisi ringkasan data yang telah dimasukkan dan langsung diarahkan kembali ke halaman utama menggunakan Navigator.pushReplacement() agar mereka tidak dapat kembali ke halaman form dengan tombol back. Cara ini lebih efisien dan cocok untuk memberikan pengalaman pengguna yang lebih baik, terutama pada proses yang bersifat satu arah seperti pengisian form. Hal ini dikarenakan pengguna cenderung hanya ingin melakukan pengisian form sekali dan kembali ke halaman utama setelahnya. Dapat disimpulkan bahwa Navigator.pushReplacement() cocok digunakan untuk perpindahan tampilan dimana pengguna cenderung tidak ingin kembali lagi ke halaman sebelumnya.

**Bagaimana kamu memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk membangun struktur halaman yang konsisten di seluruh aplikasi?**

Dalam membangun suatu aplikasi, konsistensi dari segi desain dan layout merupakan hal yang sangat penting. Hal ini harus senantiasa diterapkan agar pengguna tidak merasa kesulitan dan dapat dengan mudah memahami serta mengingat struktur aplikasi. Dengan demikian, pengguna dapat memanfaatkan aplikasi secara optimal tanpa mengalami kebingungan. Berdasarkan prinsip tersebut, saya berupaya menjaga konsistensi desain dengan memanfaatkan hierarchy widget yang sesuai, seperti Scaffold, AppBar, dan Drawer. Struktur widget tersebut menciptakan tampilan halaman yang konsisten di seluruh bagian aplikasi. Scaffold berperan sebagai kerangka utama setiap halaman yang menyediakan struktur dasar bagi widget lainnya seperti AppBar, body, dan Drawer. Pada proyek ini, setiap halaman utama dibangun menggunakan Scaffold sebagai fondasi, sehingga tampilan antar halaman menjadi seragam dan terstruktur. Selanjutnya, AppBar digunakan pada bagian atas setiap halaman untuk menampilkan judul halaman, seperti "Turboa Shop" pada halaman utama dan "Add Product Form" pada halaman form penambahan produk. Penggunaan AppBar di setiap halaman memperkuat konsistensi dari aplikasi dan memudahkan pengguna dalam mengenali konteks halaman yang sedang diakses. Selain itu, Drawer atau menu navigasi di bagian kiri juga digunakan pada setiap halaman agar pengguna dapat berpindah antarhalaman dengan mudah tanpa perlu kembali ke menu utama. Pada proyek ini, Drawer memuat dua pilihan menu, yaitu "Halaman Utama" dan "Tambah Produk". Drawer digunakan secara konsisten di seluruh halaman dengan posisi dan gaya tampilan yang sama, sehingga pengguna dapat dengan cepat mengenali fungsinya. Dengan demikian, kombinasi penggunaan hierarchy widget yang telah digunakan di setiap halaman dapat menciptakan struktur aplikasi yang konsisten, rapi, dan mudah digunakan di seluruh aplikasi.

**Dalam konteks desain antarmuka, apa kelebihan menggunakan layout widget seperti Padding, SingleChildScrollView, dan ListView saat menampilkan elemen-elemen form? Berikan contoh penggunaannya dari aplikasi kamu.**

Dalam menampilkan elemen-elemen pada halaman form, Flutter menyediakan berbagai macam layout widget yang dapat membantu mengatur tampilan antarmuka agar menjadi lebih menarik dan mudah digunakan. Beberapa di antaranya adalah Padding, SingleChildScrollView, dan ListView. Widget Padding berfungsi untuk memberikan jarak antar elemen agar tampilan tidak terlihat terlalu rapat atau sempit. Dengan padding yang konsisten, komponen seperti TextFormField, DropdownButtonFormField, dan SwitchListTile dapat terlihat lebih rapi dan nyaman dilihat. Selain itu, juga terdapat widget SingleChildScrollView yang dapat digunakan untuk membuat halaman form menjadi dapat digulir (scrollable), terutama ketika jumlah elemen dalam form cukup banyak atau aplikasi dibuka pada layar yang berukuran kecil. Dengan SingleChildScrollView, seluruh bagian atau elemen-elemen form tetap dapat diakses oleh pengguna dengan melakukan scrolling tanpa terpotong layar. Bukan hanya itu, dalam widget layout juga terdapat widget ListView yang berguna untuk menampilkan daftar elemen dalam jumlah dinamis secara vertikal. Berbeda dengan widget SingleChildScrollView, ListView sudah memiliki kemampuan scroll bawaan sehingga lebih efisien untuk antarmuka form yang memiliki banyak elemen atau daftar elemen yang panjang. Selain itu, layout widget seperti Column (untuk menata elemen secara vertikal), Row (untuk menata elemen secara horizontal), dan Container (untuk mengatur tata letak dan dekorasi widget lain di dalamnya) juga dapat digunakan untuk mengatur susunan dan dekorasi elemen pada form agar tampilan dapat terlihat lebih proporsional dan menarik. Dalam proyek Turboa Shop ini, saya menerapkan kombinasi berbagai macam layout widget pada halaman Add Product Form untuk mengatur elemen-elemen form. Setiap input seperti nama produk, harga, kategori, stok, dan deskripsi dibungkus dengan Padding agar tampilan terlihat rapih dan nyaman dilihat (tidak terlalu rapat). Kemudian, seluruh bagian atau elemen dalam form juga dibungkus oleh widget SingleChildScrollView agar tampilan elemen form dapat digulir ke bawah (scrollable) sehingga pengguna dapat mengakses seluruh elemen atau tampilan form. Saya juga menerapkan widget Column yang digunakan untuk menata setiap elemen dalam form secara vertikal. Dengan kombinasi ini, tampilan form dapat menjadi lebih rapi, responsif, serta nyaman digunakan di berbagai ukuran layar.

**Bagaimana kamu menyesuaikan warna tema agar aplikasi Football Shop memiliki identitas visual yang konsisten dengan brand toko?**

Selain memiliki tampilan yang konsisten, penting bagi sebuah aplikasi untuk memiliki design system yang konsisten agar identitas visualnya dapat dengan mudah dikenali oleh pengguna. Salah satu aspek yang paling mendasar dalam design system adalah pemilihan warna. Dalam proyek ini, saya memanfaatkan fitur bawaan Flutter yaitu ThemeData yang diatur pada file main.dart untuk menentukan color scheme atau warna tema yang akan saya gunakan di seluruh halaman aplikasi. Pemilihan warna ini juga telah disesuaikan dengan color scheme Turboa pada website. Saya menetapkan dua warna utama, yaitu warna primer (primary) berupa biru tua dan warna sekunder (secondary) berupa biru muda. Pemilihan warna biru dilakukan karena warna ini merepresentasikan rasa semangat dan juga profesionalisme yang sejalan dengan Turboa Shop sebagai toko perlengkapan sepak bola. Kombinasi antara biru tua dan biru muda juga menciptakan kesan modern, energik, dan sporty, sesuai dengan tema utama aplikasi. Penerapan warna ini dilakukan secara konsisten (sesuai) di seluruh bagian atau tampilan halaman aplikasi, seperti pada AppBar yang senantiasa menggunakan warna primer di setiap halaman, tombol "Save" (ElevatedButton) yang juga menggunakan warna primer untuk lebih menonjolkan interaksi utama yang ingin dilakukan pengguna, serta Drawer yang menggunakan warna sekunder untuk memberikan kontras atau perbedaan namun tetap harmonis dan konsisten dengan Turboa. Untuk menyesuaikan waran tema di setiap halaman, saya selalu menggunakan atau mengakses warna yang ingin digunakan melalui *Theme.of(context).colorScheme.primary* atau *Theme.of(context).colorScheme.secondary* untuk mengakses warna primer dan juga sekunder sehingga setiap elemen yang memerlukan warna mengikuti aturan tema yang telah ditentukan (dari ThemeData). Dengan cara ini, aplikasi Turboa Shop dapat menonjolkan identitas visual yang kuat dan khas melalui penggunaan color scheme yang sesuai dengan ThemeData, yaitu warna biru yang selalu digunakan di seluruh halaman aplikasi.

## Tugas 9
**Jelaskan mengapa kita perlu membuat model Dart saat mengambil/mengirim data JSON? Apa konsekuensinya jika langsung memetakan Map<String, dynamic> tanpa model (terkait validasi tipe, null-safety, maintainability)?**

Model Dart sangat penting untuk mengambil atau mengirim data JSON dikarenakan model ini berfungsi sebagai representasi terstruktur dari data yang diterima atau dikirim. Dengan menggunakan model Dart, kita dapat memastikan bahwa data yang diterima sesuai dengan tipe data yang diharapkan, sehingga dapat menghindari adanya kesalahan tipe data (type errors) yang mungkin terjadi saat memproses data. Model Dart juga membantu dalam validasi tipe data, sehingga jika ada perubahan pada struktur data JSON, kita dapat dengan mudah menyesuaikan model Dart tanpa harus mengubah seluruh kode yang berhubungan dengan data tersebut. Selain itu, model Dart juga mendukung fitur null-safety, yang memungkinkan kita untuk menangani nilai null dengan lebih aman dan mencegah potensi runtime errors yang disebabkan oleh akses ke nilai null. Dengan menggunakan model Dart, kita dapat menentukan properti mana yang wajib diisi dan mana yang bersifat opsional, sehingga meningkatkan keamanan dan keandalan aplikasi. Selain itu, penanganan untuk nilai null juga hanya perlu dilakukan satu kali di dalam contstructor JSON dengan mengatur nilai default sehingga variabel dijamin tidak akan pernah null. Dari segi maintainability, penggunaan model Dart juga dapat membuat kode menjadi lebih terorganisir dan mudah dipahami. Ketika ada perubahan pada struktur data JSON, kita hanya perlu memperbarui model Dart tanpa harus mencari dan mengubah setiap bagian kode yang berinteraksi dengan data tersebut. Hal ini membuat pengembangan aplikasi menjadi lebih efisien dan mengurangi risiko kesalahan. Penggunaan model Dart juga mempermudah pembacaan kode karena hanya perlu mengetik model.properti, seperti produk.price untuk mengakses harga produk. Jika kita langsung memetakan data JSON ke dalam Map<String, dynamic> tanpa menggunakan model Dart, kita akan kehilangan hal-hal tersebut. Kode akan menjadi lebih rentan terhadap kesalahan tipe data, sulit untuk menangani nilai null dengan aman, dan sulit untuk memelihara kode ketika ada perubahan pada struktur data JSON. Map<String, dynamic> berarti bahwa data bisa berupa apa saja atau dynamic. Hal ini bisa saja mengakibatkan kesalahan dalam tipe data yang bersangkutan, misalnya ketika ingin diambil price dalam map, bisa saja price berupa int, double ataupun String yang ketika dioperasikan (misal +10) akan menimbulkan error. Selain itu, dari segi null safety, map bisa saja menampilkan atau mengembalikan null ketika tidak dimiliki key yang bersangkutan. Hal ini dapat menyebabkan crash pada aplikasi dikarenakan widget tidak dapat menerima null. Oleh karena itu, penggunaan model Dart sangat dianjurkan untuk memastikan integritas data, keamanan aplikasi, dan kemudahan dalam pengembangan serta pemeliharaan kode.

**Apa fungsi package http dan CookieRequest dalam tugas ini? Jelaskan perbedaan peran http vs CookieRequest.**

Package http dan CookieRequest sangat bermanfaat dalam tugas ini. Package http adalah library yang digunakan untuk melakukan HTTP request ke server, seperti GET, POST, PUT, DELETE, dan lain-lain. Dengan package ini, kita dapat mengirim permintaan ke backend Django untuk mengambil data JSON, mengirim data baru, memperbarui data yang sudah ada, dan menghapus data. Package http menyediakan cara yang sederhana dan efisien untuk berkomunikasi dengan server melalui protokol HTTP. Dalam konteks tugas ini, package http digunakan untuk mengambil data produk dari endpoint JSON di Django dan menampilkannya di aplikasi Flutter. Package http bersifat stateless yang berarti bahwa setiap panggilan atau request yang dilakukan akan dianggap sebagai suatu panggilan baru. Sedangkan, CookieRequest adalah sebuah class yang merupakan bagian dari package pbp_django_auth yang berfungsi untuk mengelola sesi autentikasi menggunakan cookie. CookieRequest dapat dikatakan sebagai "pembungkus" (wrapper) khusus yang menggunakan http untuk membuat request yang secara otomatis mengelola cookie login (autentikasi). CookieRequest memungkinkan kita untuk menyimpan dan mengirim cookie sesi secara otomatis saat melakukan HTTP request ke backend Django. Package ini bersifat stateful atau menyimpan status pengguna atau request yang dilakukan sebelumnya. Hal ini sangat penting dalam konteks autentikasi dikarenakan server Django menggunakan cookie untuk mengidentifikasi pengguna yang sedang login. Dengan CookieRequest, kita dapat memastikan bahwa setiap permintaan yang dikirim ke server menyertakan cookie sesi yang valid, sehingga server dapat mengenali pengguna dan memberikan akses sesuai dengan hak aksesnya. Hal ini dikarenakan ketika request dipanggil, paket ini akan secara otomatis menyimpan cookie sessionid dan mengirimkannya setiap kali ingin dilakukan request lain sehingga dapat dikenali oleh Django. Perbedaan utama antara package http dan CookieRequest terletak pada fungsinya. Package http fokus pada pengiriman dan penerimaan data melalui HTTP request dan bersifat stateles, sedangkan CookieRequest fokus pada manajemen sesi autentikasi menggunakan cookie dan bersifat stateful. Dalam tugas ini, package http digunakan untuk mengambil data produk dan mengirim data produk ke Django, sedangkan CookieRequest digunakan untuk mengelola mekanisme autentikasi pengguna, seperti login, register, dan logout. Dengan adanya CookieRequest, Django dapat mengenali pengguna yang sedang login di saat ini sehingga dapat memberikan hak akses yang sesuai, misalnya menghapus atau mengedit produk yang terasosiasi dengan pengguna. Dengan menggunakan kedua package ini secara bersamaan, kita dapat membangun aplikasi Flutter yang tidak hanya dapat berkomunikasi dengan backend Django tetapi juga dapat mengelola sesi autentikasi dengan aman dan efisien.

**Jelaskan mengapa instance CookieRequest perlu untuk dibagikan ke semua komponen di aplikasi Flutter.**

Instance CookieRequest perlu dibagikan ke semua komponen di aplikasi Flutter dikarenakan CookieRequest berfungsi sebagai pengelola sesi autentikasi yang menggunakan cookie untuk mengidentifikasi pengguna yang sedang login. Dengan membagikan instance CookieRequest ke seluruh komponen aplikasi, kita dapat memastikan bahwa setiap bagian dari aplikasi dapat mengetahui informasi sesi mengenai pengguna yang sedang aktif. Hal ini sangat penting dalam konteks aplikasi yang memerlukan autentikasi, di mana berbagai halaman atau fitur dalam aplikasi bisa saja memerlukan informasi tentang status login pengguna atau data pengguna yang sedang aktif. Seperti pada projek ini, untuk dapat mengakses aplikasi dan informasi mengenai produk, pengguna harus login terlebih dahulu. Selain itu, untuk menambahkan suatu produk, Django harus mengetahui informasi pengguna yang sedang login untuk diasosiasikan dengan produk yang dibuat. Dengan menggunakan instance CookieRequest yang sama di seluruh aplikasi, kita dapat memastikan adanya konsistensi dalam pengelolaan sesi autentikasi. Ketika pengguna login, informasi sesi akan disimpan dalam instance CookieRequest, dan setiap kali pengguna mengakses halaman lain atau melakukan permintaan ke backend Django, instance CookieRequest akan menyertakan cookie sesi yang valid yang terhubung dengan aktivitas login pengguna tersebut. Hal ini memungkinkan server Django untuk mengenali pengguna dan memberikan akses sesuai dengan hak aksesnya. Selain itu, dengan membagikan instance CookieRequest ke seluruh komponen, kita dapat menghindari duplikasi kode dan memastikan bahwa semua bagian aplikasi menggunakan mekanisme autentikasi yang sama. Hal ini membuat pengelolaan sesi menjadi lebih efisien dan memudahkan pemeliharaan kode. Jika instance CookieRequest tidak dibagikan ke seluruh komponen, maka setiap bagian aplikasi mungkin harus membuat instance baru atau mengelola sesi secara terpisah, yang dapat menyebabkan inkonsistensi dan kesulitan dalam pengelolaan autentikasi. Misalnya, di dalam proyek ini pengguna sudah melakukan login. Namun, karena tidak digunakan instance CookieRequest yang sama di seluruh aplikasi, ketika pengguna ingin menambahkan produk, Django tidak mengenali sesi login pengguna tersebut dikarenakan instance CookieRequest yang digunakan pada halaman form berbeda dengan instance CookieRequest yang digunakan pada halaman login. Akibatnya, pengguna tidak dapat menambahkan produk karena Django menganggap pengguna belum login. 

**Jelaskan konfigurasi konektivitas yang diperlukan agar Flutter dapat berkomunikasi dengan Django. Mengapa kita perlu menambahkan 10.0.2.2 pada ALLOWED_HOSTS, mengaktifkan CORS dan pengaturan SameSite/cookie, dan menambahkan izin akses internet di Android? Apa yang akan terjadi jika konfigurasi tersebut tidak dilakukan dengan benar?**

Dalam menghubungkan aplikasi Flutter dengan backend Django, terdapat beberapa konfigurasi konektivitas yang perlu dilakukan agar komunikasi dan hubungan antara keduanya dapat berjalan dengan baik. Pertama, harus ditambahkan 10.0.2.2 pada ALLOWED_HOSTS di settings.py Django. 10.0.2.2 merupakan alamat IP khusus yang digunakan oleh emulator Android untuk mengakses localhost dari komputer host atau developer. Dengan menambahkan alamat ini ke ALLOWED_HOSTS, Django akan mengizinkan permintaan yang berasal dari emulator Android, sehingga aplikasi Flutter yang berjalan di emulator dapat berkomunikasi dengan server Django yang berjalan di localhost. Jika konfigurasi ini tidak dilakukan, maka permintaan dari aplikasi Flutter ke Django akan ditolak karena Django tidak mengenali alamat asal permintaan tersebut (mengembalikan error 400 dikarenakan berasal dari host yang tidak diperbolehkan). Selanjutnya, kita juga perlu mengaktifkan CORS (Cross-Origin Resource Sharing) di Django dengan menggunakan library django-cors-headers. CORS adalah mekanisme keamanan yang membatasi sumber daya web agar hanya dapat diakses dari domain tertentu. Dengan mengaktifkan CORS dan mengonfigurasi pengaturan yang sesuai, kita dapat mengizinkan aplikasi Flutter untuk mengakses sumber daya dari backend Django. Hal ini penting karena Flutter dan Django biasanya berjalan pada domain atau port yang berbeda, sehingga tanpa konfigurasi CORS yang tepat, permintaan dari Flutter ke Django akan diblokir oleh browser atau server. Jika konfigurasi CORS tidak dilakukan dengan benar, maka aplikasi Flutter tidak akan dapat mengambil data dari Django atau mengirim data ke Django (terjadi CORS error), sehingga fungsionalitas aplikasi akan terganggu. Selain itu, perlu juga mengatur pengaturan SameSite dan cookie di Django. Pengaturan SameSite pada cookie menentukan bagaimana cookie dikirimkan dalam permintaan lintas situs. Dengan mengatur SameSite(CSRF_COOKIE_SAMESTIE dan SESSION_COOKIE_SAMESITE) = 'None' dan Secure=True, kita memastikan bahwa cookie sesi dapat dikirimkan bersama dengan permintaan dari aplikasi Flutter ke Django, sehingga sesi autentikasi dapat dikenali dengan benar. Jika pengaturan ini tidak dilakukan dengan benar, maka cookie sesi mungkin tidak akan dikirimkan, sehingga Django tidak akan mengenali pengguna yang sedang login, yang dapat menyebabkan masalah dalam autentikasi dan akses data. Terakhir, perlu ditambahkan izin akses internet di file AndroidManifest.xml pada proyek Flutter. Izin ini diperlukan agar aplikasi Flutter dapat melakukan koneksi jaringan dan mengirim permintaan HTTP ke backend Django. Tanpa izin ini, aplikasi Flutter tidak akan dapat mengakses internet, sehingga tidak dapat berkomunikasi dengan Django. Jika izin akses internet tidak ditambahkan, maka semua permintaan jaringan dari aplikasi Flutter akan gagal, yang akan mengakibatkan aplikasi tidak dapat mengambil atau mengirim data ke backend Django. 

**Jelaskan mekanisme pengiriman data mulai dari input hingga dapat ditampilkan pada Flutter.**

Mekanisme pengiriman data ini dimulai dari proses input pengguna pada halaman form di aplikasi Flutter. Ketika pengguna mengisi form (TextFormField) dan menekan tombol "Save", aplikasi Flutter akan mengumpulkan data yang telah diketik atau dimasukkan oleh pengguna, seperti nama produk, harga, kategori, stok, dan deskripsi. Pada proses ini, Form pada Flutter akan memastikan bahwa semua data yang dikirim oleh pengguna merupakan data yang valid. Data ini kemudian dikemas menjadi format JSON (melalui jsonEncode({})) agar dapat dikirimkan ke backend Django melalui HTTP request. Setelah data dikemas dalam format JSON, aplikasi Flutter akan menggunakan package http atau CookieRequest untuk mengirimkan permintaan POST ke endpoint tertentu di backend Django yang telah disiapkan untuk menerima data produk baru. Permintaan ini akan menyertakan data JSON yang berisi informasi produk yang telah diinputkan oleh pengguna. Setelah permintaan dikirimkan, backend Django akan menerima data tersebut dan memprosesnya. Django akan melakukan validasi terhadap data yang diterima untuk memastikan bahwa semua informasi yang diperlukan telah lengkap dan sesuai dengan format yang diharapkan. Jika validasi berhasil, Django akan menyimpan data produk baru ke dalam database. View akan mengubah JSON string (data yang dikirim Flutter) menjadi dictionay yang nantinya akan diubah menjadi instance Model dan disimpan di database. Setelah data berhasil disimpan, Django akan mengirimkan respons kembali ke aplikasi Flutter sebagai konfirmasi bahwa data telah berhasil diterima dan disimpan. Respons ini biasanya berisi status keberhasilan dan mungkin juga informasi tambahan tentang produk yang baru saja ditambahkan. Setelah menerima respons dari Django, aplikasi Flutter akan memproses respons tersebut. Pada proyek ini, setelah menerima respons atau status bahwa data telah berhasil disimpan, aplikasi Flutter akan melakukan routing ke halaman ProductEntryListPage yang berisi daftar semua produk untuk menampilkan daftar semua produk beserta produk baru yang dimasukkan sebelumnya. Pada proses ini, aplikasi Flutter akan melakukan permintaan GET ke backend Django untuk mengambil data produk terbaru dari database. Setelah menerima data produk dalam format JSON dari Django, aplikasi Flutter akan mengonversi data JSON tersebut menjadi model Dart (ProductEntry) yang telah dibuat sebelumnya. Data produk yang telah diubah menjadi model Dart ini kemudian akan ditampilkan di halaman ProductEntryListPage dalam bentuk card yang berisi informasi produk. Dengan demikian, pengguna dapat melihat produk baru yang telah mereka tambahkan beserta produk lainnya yang ada di database.

**Jelaskan mekanisme autentikasi dari login, register, hingga logout. Mulai dari input data akun pada Flutter ke Django hingga selesainya proses autentikasi oleh Django dan tampilnya menu pada Flutter.**

Mekanisme autentikasi sangat bergantung pada CookieRequest sebagai pengelola sesi. Proses autentikasi dimulai ketika pengguna mengakses halaman login atau register pada aplikasi Flutter. Ketika pengguna belum memiliki akun, pengguna akan dialihkan ke halaman register untuk membuat akun baru. Pada halaman register, pengguna akan memasukkan data seperti username, password, dan informasi lainnya ke dalam form registrasi. Setelah menekan tombol "Register", data input akan dikemas dalam format JSON dan dikirimkan ke backend Django melalui permintaan POST menggunakan CookieRequest ke endpoint register yang telah disiapkan di Django. Django akan memproses data registrasi dengan memvalidasi informasi yang diberikan dan menyimpannya ke dalam database (dalam bentuk model User) jika valid. Setelah berhasil mendaftar, Django akan mengirimkan respons kembali ke aplikasi Flutter sebagai konfirmasi bahwa pendaftaran berhasil. Setelah berhasil mendaftar, pengguna akan diarahkan kembali ke halaman login untuk masuk menggunakan akun yang baru dibuat. Pada kondisi ini, CookieRequest pada pengguna di Flutter masih kosong, tetapi sudah ada user baru di database. Pada halaman login, pengguna akan memasukkan username dan password mereka ke dalam form yang telah disediakan. Setelah pengguna menekan tombol "Login", aplikasi Flutter akan mengumpulkan data input tersebut dan mengemasnya dalam format JSON. Data JSON ini kemudian dikirimkan ke backend Django melalui permintaan POST menggunakan CookieRequest ke endpoint login yang telah disiapkan di Django. Setelah menerima permintaan login, Django akan memproses data yang diterima dengan memeriksa apakah username dan password yang diberikan sesuai dengan data yang ada di database. Jika data valid, Django akan membuat sesi autentikasi untuk pengguna tersebut dan mengirimkan respons kembali ke aplikasi Flutter, termasuk cookie sesi yang berisi informasi autentikasi. CookieRequest di Flutter akan secara otomatis menyimpan cookie sesi ini untuk digunakan pada permintaan selanjutnya. Setelah menerima respons dari Django, aplikasi Flutter akan memeriksa status respons tersebut. Jika login berhasil, aplikasi akan mengarahkan pengguna ke halaman utama aplikasi dan menampilkan menu yang sesuai dengan status login pengguna. Untuk proses logout, ketika pengguna menekan tombol "Logout" di aplikasi Flutter, aplikasi akan mengirimkan permintaan POST ke endpoint logout di backend Django menggunakan CookieRequest. Permintaan ini akan menyertakan cookie sesi yang telah disimpan sebelumnya. Django akan memproses permintaan logout dengan menghapus sesi autentikasi yang terkait dengan cookie sesi tersebut. Setelah berhasil logout, Django akan mengirimkan respons kembali ke aplikasi Flutter sebagai konfirmasi bahwa logout berhasil. Aplikasi Flutter kemudian akan mengarahkan pengguna kembali ke halaman login dan menghapus informasi sesi dari CookieRequest untuk memastikan bahwa pengguna tidak lagi memiliki akses ke fitur yang memerlukan autentikasi.

**Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step! (bukan hanya sekadar mengikuti tutorial).**

**Memastikan deployment proyek tugas Django kamu telah berjalan dengan baik.**

1. Mengecek kembali proyek Django yang sebelumnya
2. Menjalankan proyek tersebut di localhost dan memastikan semuanya berjalan dengan lancar

**Mengintegrasikan sistem autentikasi Django dengan proyek tugas Flutter.**

1. Membuat suatu aplikasi baru pada proyek Django bernama authentication dengan *python manage.py startapp authentication*
2. Mendaftarkan authentication pada INSTALLED_APPS main Django.
3. Menginstall library django-cors-headers, menambahkannya ke requirements.txt dan mengaturnya di setting agar dapat dikenali oleh Django. Hal ini dilakukan agar Flutter dapat dihubungkan ke Django dan tidak diblokir oleh CORS (Cross Origin Resource Sharing)
4. Menambahkan variabel untuk mengonfigurasi kebijakan CORS, cookie, dan session di settings.py agar Flutter dapat mengakses Django.
5. Menambahkan host 10.0.2.2 pada settings.py untuk emulator Android.
6. Membuat function login dan konfigurasi routing untuk app authentication
7. Mengunduh package yang telah disediakan oleh tim asisten dosen yaitu provider dan pbp_django_auth. Provider untuk manajemen state atau kondisi, seperti menyimpan data yang dibutuhkan banyak halaman (status login, user info) dan memudahkan Flutter untuk memantau perubahan data. pbp_django_auth untuk menghubungkan Flutter dengan Django (login, logout) 
8. Modifikasi root widget agar dapat menyediakan CookieRequest ke seluruh widget atau halaman dalam aplikasi. Root widget harus dibungkus dengan Provider kemudian harus dibuat instance CookieRequest di dalamnya. Hal ini dilakukan agar setiap halaman dapat mengakses informasi user yang sedang login serta cookie sesi yang terkait.

**Mengimplementasikan fitur registrasi akun pada proyek tugas Flutter.**

1. Menambahkan function untuk register pada Django di bagian aplikasi authentication, yaitu pada file views.py
* Menggunakan csrf exempt (menonaktifkan proteksi CSRF) dikarenakan Flutter tidak memiliki CSRF token karena bukan browser.
2. Mengonfigurasi urls.py pada folder authentication untuk menambahkan routing terhadap function register
3. Membuat file baru yaitu register.dart pada folder screens
4. Memodifikasi file register.dart dengan kode yang dibutuhkan
* Menggunakan statefulwidget dikarenakan page registrasi akan berubah-ubah seiring input pengguna
* Digunakan ElevatedButton async agar request dari pengguna dapat berjalan secara asinkronus sementara respons menunggu dari Django
* Digunakan TextEditingController() untuk menerima input dari user. TextField tidak dapat menyimpan state sendiri, sehingga dibutuhkan controller untuk membaca dan mengatur input.
5. Mengimport file register.dart dan menghubungkannya dengan fungsi onTap pada bagian login.dart yang mengarahkan ke fungsi register agar dapat berfungsi atau berpindah halaman dengan baik

**Membuat halaman login pada proyek tugas Flutter.**

1. Menambahkan function untuk login pada Django di bagian aplikasi authentication, yaitu pada file views.py
* Menggunakan csrf exempt (menonaktifkan proteksi CSRF) dikarenakan Flutter tidak memiliki CSRF token karena bukan browser.
2. Mengonfigurasi urls.py pada folder authentication untuk menambahkan routing terhadap function login
3. Menginclude urls untuk authentication pada file football_news/urls.py agar dapat diarahkan ke halaman autentikasi
4. Membuat file baru yaitu login.dart pada folder screens
5. Memodifikasi file login.dart dengan kode yang dibutuhkan
* Digunakan StatelessWidget pada LoginApp dan StatefullWidget pada LoginPage. Hal ini dikarenakan LoginApp hanya menyimpan informasi yang tidak berubah seperti theme dan title, namun LoginPage akan senantiasa berubah sesuai dengan keadaan(state), misalnya username dan password yang akan menyesuaikan dengan input user.
* Digunakan widget TextField untuk input pengguna, bagian password akan digunakan properti obscureText agar password tidak ditampilkan secara jelas
* Digunakan ElevatedButton async agar request dari pengguna dapat berjalan secara asinkronus
6. Mengubah routing untuk main.dart agar tampilan pertama kali yang dilihat pengguna adalah LoginPage()

**Membuat model kustom sesuai dengan proyek aplikasi Django.**

* Pembuatan model kustom ini menggunakan website bantuan, yaitu Quicktype
1. Membuka atau mengakses http://localhost:8000/json untuk endpoint JSON dari proyek Django yang telah dibuat
2. Menyalin semua data pada tautan tersebut 
3. Membuka situs web Quicktype
4. Mengubah nama menjadi ProductEntry, source type menjadi JSON (karena data dari JSON), dan language menjadi Dart (karena flutter menggunakan Dart).
5. Menempelkan data JSON yang telah disalin ke textbox sebelah kiri.
6. Menyalin kode pada Quicktype atau menekan tombol Copy Code
7. Membuat folder baru bernama models di lib dan menyalin kode tersebut pada file baru bernama news_entry.dart di dalam lib/models/.

**Membuat halaman yang berisi daftar semua item yang terdapat pada endpoint JSON di Django yang telah kamu deploy.**

1. Menambahkan package http agar dapat melakukan perintah http request dengan mengetik *flutter pub add http*. Hal ini dilakukan agar Flutter dapat melakukan HTTP request ke backend Django dan menerima data JSON.
2. Di file android/app/src/main/AndroidManifest.xml, tambahkan <uses-permission android:name="android.permission.INTERNET" /> untuk memperbolehkan akses internet pada Flutter
3. Mengimport request pada main/views.py pada proyek Django
4. Menambahkan fungsi proxy_image untuk perantara mengambil gambar dari URL lain dan mengirimkannya ke Flutter (untuk thumbnail produk)
5. Mengonfigurasi path pada main/urls.py untuk fungsi proxy_image
6. Membuat file baru bernama product_entry_card.dart pada folder lib/widgets sebagai template untuk card product. Pada card product, hanya beberapa info penting yang ditampilkan yaitu thumbnail, nama, category, description, is featured, harga, rating, dan brand
* Data yang diambil dihubungkan dengan Django, seperti pada thumbnail dihubungkan dengan fungsi proxy-image untuk mendapatkan url dan untuk elemen lainnya diambil dari ProductEntry yang telah dibuat sebelumnya
7. Membuat file baru, yaitu product_entry_list.dart untuk menampilkan semua produk yang terdapat pada database dalam bentuk card.
* Menggunakan async agar fungsi untuk mengambil data JSON dari Django berjalan secara asinkronus
* Menggunakan Future untuk menampung hasil request data ke Django dikarenakan datanya belum bisa digunakan saat ini atau sekarang
* Menggunakan CookieRequest agar Django dapat mengetahui user mana yang sedang login saat ini
* Menggunakan AsyncSnapshot untuk mengetahui status Future saat ini dan akan ditampilkan data sesuai dengan kondisi Future. Misalnya, ketika snapshot atau kondisi Future saat ini belum memiliki data, maka akan ditampilkan loading atau widget CircularProgressIndicator yang berarti sedang menunggu untuk mendapatkan data.
* Mengimport package intl untuk formatting harga dalam Indonesia, misalnya dengan menggunakan Rp dan menambahkan . di setiap 3 angka. Untuk dapat menggunakannya, di pubspec.yaml, akan ditambahkan dependensi baru yaitu intl: ^0.18.1 lalu melakukan flutter pub get untuk mendapatkan dependensi baru.
8. Menambahkan ListTile 'All Product' atau ListTile baru yang akan mengarahkan ke halaman ProductEntryListPage yang menampilkan seluruh card produk.
9. Mengubah fungsi tombol atau button di halaman utama agar dapat diarahkan atau routing ke halaman ProductEntryListPage. Tombol yang diubah adalah tombol "All Products". 

**Membuat halaman detail untuk setiap item yang terdapat pada halaman daftar Item.**

1. Membuat file baru yaitu product_detail.dart pada folder lib/screens di Flutter sebagai tampilan ketika membuka detail produk. 
* Menampilkan semua komponen atau informasi pada produk
2. Mengubah file product_entry_list.dart pada lib/screens/ untuk menambahkan routing atau navigasi ke halaman detail produk yang bersangkutan

**Melakukan filter pada halaman daftar item dengan hanya menampilkan item yang terasosiasi dengan pengguna yang login.**

1. Membuat kategori untuk filter pada product_entry_list.dart dengan enum yang memiliki dua nilai, yaitu all dan myProducts. All yang berarti ingin ditampilkan semua produk, myProducts yang berarti hanya menampilkan produk yang terasosiasi dengan pengguna yang sedang login. 
2. Menambahkan contsructor untuk filter yang dipilih dengan initialFilter dengan nilai awal atau inisialisasi yaitu all atau semua produk
3. Menambahkan fungsi baru pada proyek Django pada bagian main/views.py yaitu get_my_product_json untuk mendapatkan data json produk yang hanya terasosisasi dengan pengguna yang sedang login. 
4. Mengonfigurasi routing url pada path di file main/views.py
5. Menambahkan fungsi pada fetchProducts untuk validasi sesuai dengan filter yang dipilih pada file product_entry_list.dart dengan memanfaatkan fungsi pada Django
6. Menambahkan ListTile baru pada left_drawer.dart, yaitu My Products yang hanya menampilkan card product yang terasosiasi dengan pengguna yang sedang login
7. Mengubah fungsi tombol atau button di halaman utama agar dapat diarahkan atau routing ke halaman ProductEntryListPage. Tombol yang diubah adalah tombol "My Products" dengan initialFilternya adalah ProductFilter.myProducts. 

**Tambahan**
**Integrasi Form Flutter dengan Django**

1. Membuat sebuah fungsi baru pada views.py di folder main proyek Django yaitu create_product_flutter yang berfungsi untuk menerima data dari Flutter mengenai produk baru yang ingin ditambahkan.
* Digunakan strip tags agar datanya bersih
2. Mengonfigurasi path pada main/urls.py untuk fungsi create_product_flutter
3. Menambahkan import untuk package provider dan pbp_django_auth pada productlist_form.dart
4. Menghubungkan halaman productlist_form.dart dengan CookieRequest agar dapat menerima cookie dari user yang bersangkutan
5. Mengubah perintah onpressed untuk submit form menjadi async dan menghubungkan data yang bersangkutan dengan fungsi create_product_flutter.

**Implementasi Fitur Logout**

1. Menambahkan fungsi baru pada file views.py di folder authentication proyek Django yaitu logout.
2. Mengonfigurasi rute url pada authentication/urls.py untuk fungsi logout
3. Mengimport package pbp_django_auth dan provider pada left_drawer.dart dan mengubah metode build untuk menambahkan CookieRequest
4. Menambahkan ListTile baru untuk logout 
* Menggunakan fungsi async agar dapat berjalan secara asinkronus